package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"github.com/cockroachdb/errors"
	"github.com/miyamo2/altnrslog"
	"github.com/miyamo2/api.miyamo.today/core/log"
	"log/slog"

	"github.com/miyamo2/api.miyamo.today/core/util/duration"
	"github.com/miyamo2/blogapi/internal/app/usecase/dto"
	"github.com/miyamo2/blogapi/internal/if-adapter/presenters/graphql/model"
	"github.com/newrelic/go-agent/v3/integrations/nrpkgerrors"
	"github.com/newrelic/go-agent/v3/newrelic"
)

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context, first *int, last *int, after *string, before *string) (*model.ArticleConnection, error) {
	nrtx := newrelic.FromContext(ctx)
	defer nrtx.StartSegment("Articles").End()
	dw := duration.Start()
	lgr, err := altnrslog.FromContext(ctx)
	if err != nil {
		err = errors.WithStack(err)
		nrtx.NoticeError(nrpkgerrors.Wrap(err))
		lgr = log.DefaultLogger()
	}
	lgr.InfoContext(ctx, "BEGIN",
		slog.Group("parameters",
			slog.Any("first", first),
			slog.Any("last", last),
			slog.Any("after", after),
			slog.Any("before", before)))
	opts := make([]dto.ArticlesInDtoOption, 0, 4)
	if first != nil {
		opts = append(opts, dto.ArticlesInWithFirst(*first))
	}
	if last != nil {
		opts = append(opts, dto.ArticlesInWithLast(*last))
	}
	if after != nil {
		opts = append(opts, dto.ArticlesInWithAfter(*after))
	}
	if before != nil {
		opts = append(opts, dto.ArticlesInWithBefore(*before))
	}
	in, err := dto.NewArticlesInDto(opts...)
	if err != nil {
		err = errors.WithStack(err)
		nrtx.NoticeError(nrpkgerrors.Wrap(err))
		lgr.WarnContext(ctx, "END",
			slog.String("duration", dw.SDuration()),
			slog.Group("returns",
				slog.Any("*model.ArticleConnection", nil),
				slog.Any("error", err)))
		return nil, err
	}
	oDto, err := r.usecases.articles.Execute(ctx, in)
	if err != nil {
		err = errors.WithStack(err)
		nrtx.NoticeError(nrpkgerrors.Wrap(err))
		lgr.WarnContext(ctx, "END",
			slog.String("duration", dw.SDuration()),
			slog.Group("returns",
				slog.Any("*model.ArticleConnection", nil),
				slog.Any("error", err)))
		return nil, err
	}
	cnctn, ok := r.converters.articles.ToArticles(ctx, oDto)
	if !ok {
		err := ErrFailedToConvertToArticleConnection
		lgr.InfoContext(ctx, "END",
			slog.String("duration", dw.SDuration()),
			slog.Group("returns",
				slog.Any("*model.ArticleConnection", nil),
				slog.Any("error", err)))
		nrtx.NoticeError(nrpkgerrors.Wrap(err))
		return nil, err
	}
	lgr.InfoContext(ctx, "END",
		slog.String("duration", dw.SDuration()),
		slog.Group("returns",
			slog.Any("*model.ArticleConnection", &cnctn),
			slog.Any("error", nil)))
	return cnctn, nil
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id string) (*model.ArticleNode, error) {
	nrtx := newrelic.FromContext(ctx)
	defer nrtx.StartSegment("Article").End()
	dw := duration.Start()
	lgr, err := altnrslog.FromContext(ctx)
	if err != nil {
		err = errors.WithStack(err)
		nrtx.NoticeError(nrpkgerrors.Wrap(err))
		lgr = log.DefaultLogger()
	}
	lgr.InfoContext(ctx, "BEGIN",
		slog.Group("parameters", slog.String("id", id)))
	oDto, err := r.usecases.article.Execute(ctx, dto.NewArticleInDto(id))
	if err != nil {
		err = errors.WithStack(err)
		nrtx.NoticeError(nrpkgerrors.Wrap(err))
		lgr.WarnContext(ctx, "END",
			slog.String("duration", dw.SDuration()),
			slog.Group("returns",
				slog.Any("*model.ArticleNode", nil),
				slog.Any("error", err)))
		return nil, err
	}
	nd, ok := r.converters.article.ToArticle(ctx, oDto)
	if !ok {
		err := ErrFailedToConvertToArticleNode
		lgr.InfoContext(ctx, "END",
			slog.String("duration", dw.SDuration()),
			slog.Group("returns",
				slog.Any("*model.ArticleNode", nil),
				slog.Any("error", err)))
		nrtx.NoticeError(nrpkgerrors.Wrap(err))
		return nil, err
	}
	lgr.InfoContext(ctx, "END",
		slog.String("duration", dw.SDuration()),
		slog.Group("returns",
			slog.Any("*model.ArticleNode", &nd),
			slog.Any("error", nil)))
	return nd, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var (
	ErrFailedToConvertToArticleNode       = errors.New("failed to convert to article node")
	ErrFailedToConvertToArticleConnection = errors.New("failed to convert to article connection")
)
