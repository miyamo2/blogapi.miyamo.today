// Code generated by MockGen. DO NOT EDIT.
// Source: converter.go
//
// Generated by this command:
//
//	mockgen -source=converter.go -destination=../../../../../../mock/if-adapter/controller/graphql/resolver/presenter/converter/mock_converter.go -package=converter
//
// Package converter is a generated GoMock package.
package converter

import (
	context "context"
	reflect "reflect"

	dto "github.com/miyamo2/blogapi.miyamo.today/federator/internal/if-adapter/controller/graphql/resolver/usecase/dto"
	model "github.com/miyamo2/blogapi.miyamo.today/federator/internal/if-adapter/presenters/graphql/model"
	gomock "go.uber.org/mock/gomock"
)

// MockArticleConverter is a mock of ArticleConverter interface.
type MockArticleConverter[T dto.Tag, AT dto.ArticleTag[T], O dto.ArticleOutDto[T, AT]] struct {
	ctrl     *gomock.Controller
	recorder *MockArticleConverterMockRecorder[T, AT, O]
}

// MockArticleConverterMockRecorder is the mock recorder for MockArticleConverter.
type MockArticleConverterMockRecorder[T dto.Tag, AT dto.ArticleTag[T], O dto.ArticleOutDto[T, AT]] struct {
	mock *MockArticleConverter[T, AT, O]
}

// NewMockArticleConverter creates a new mock instance.
func NewMockArticleConverter[T dto.Tag, AT dto.ArticleTag[T], O dto.ArticleOutDto[T, AT]](ctrl *gomock.Controller) *MockArticleConverter[T, AT, O] {
	mock := &MockArticleConverter[T, AT, O]{ctrl: ctrl}
	mock.recorder = &MockArticleConverterMockRecorder[T, AT, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArticleConverter[T, AT, O]) EXPECT() *MockArticleConverterMockRecorder[T, AT, O] {
	return m.recorder
}

// ToArticle mocks base method.
func (m *MockArticleConverter[T, AT, O]) ToArticle(ctx context.Context, from O) (*model.ArticleNode, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToArticle", ctx, from)
	ret0, _ := ret[0].(*model.ArticleNode)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ToArticle indicates an expected call of ToArticle.
func (mr *MockArticleConverterMockRecorder[T, AT, O]) ToArticle(ctx, from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToArticle", reflect.TypeOf((*MockArticleConverter[T, AT, O])(nil).ToArticle), ctx, from)
}

// MockArticlesConverter is a mock of ArticlesConverter interface.
type MockArticlesConverter[T dto.Tag, AT dto.ArticleTag[T], O dto.ArticlesOutDto[T, AT]] struct {
	ctrl     *gomock.Controller
	recorder *MockArticlesConverterMockRecorder[T, AT, O]
}

// MockArticlesConverterMockRecorder is the mock recorder for MockArticlesConverter.
type MockArticlesConverterMockRecorder[T dto.Tag, AT dto.ArticleTag[T], O dto.ArticlesOutDto[T, AT]] struct {
	mock *MockArticlesConverter[T, AT, O]
}

// NewMockArticlesConverter creates a new mock instance.
func NewMockArticlesConverter[T dto.Tag, AT dto.ArticleTag[T], O dto.ArticlesOutDto[T, AT]](ctrl *gomock.Controller) *MockArticlesConverter[T, AT, O] {
	mock := &MockArticlesConverter[T, AT, O]{ctrl: ctrl}
	mock.recorder = &MockArticlesConverterMockRecorder[T, AT, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArticlesConverter[T, AT, O]) EXPECT() *MockArticlesConverterMockRecorder[T, AT, O] {
	return m.recorder
}

// ToArticles mocks base method.
func (m *MockArticlesConverter[T, AT, O]) ToArticles(ctx context.Context, from O) (*model.ArticleConnection, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToArticles", ctx, from)
	ret0, _ := ret[0].(*model.ArticleConnection)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ToArticles indicates an expected call of ToArticles.
func (mr *MockArticlesConverterMockRecorder[T, AT, O]) ToArticles(ctx, from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToArticles", reflect.TypeOf((*MockArticlesConverter[T, AT, O])(nil).ToArticles), ctx, from)
}

// MockTagConverter is a mock of TagConverter interface.
type MockTagConverter[A dto.Article, TA dto.TagArticle[A], O dto.TagOutDto[A, TA]] struct {
	ctrl     *gomock.Controller
	recorder *MockTagConverterMockRecorder[A, TA, O]
}

// MockTagConverterMockRecorder is the mock recorder for MockTagConverter.
type MockTagConverterMockRecorder[A dto.Article, TA dto.TagArticle[A], O dto.TagOutDto[A, TA]] struct {
	mock *MockTagConverter[A, TA, O]
}

// NewMockTagConverter creates a new mock instance.
func NewMockTagConverter[A dto.Article, TA dto.TagArticle[A], O dto.TagOutDto[A, TA]](ctrl *gomock.Controller) *MockTagConverter[A, TA, O] {
	mock := &MockTagConverter[A, TA, O]{ctrl: ctrl}
	mock.recorder = &MockTagConverterMockRecorder[A, TA, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagConverter[A, TA, O]) EXPECT() *MockTagConverterMockRecorder[A, TA, O] {
	return m.recorder
}

// ToTag mocks base method.
func (m *MockTagConverter[A, TA, O]) ToTag(ctx context.Context, from O) (*model.TagNode, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToTag", ctx, from)
	ret0, _ := ret[0].(*model.TagNode)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ToTag indicates an expected call of ToTag.
func (mr *MockTagConverterMockRecorder[A, TA, O]) ToTag(ctx, from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToTag", reflect.TypeOf((*MockTagConverter[A, TA, O])(nil).ToTag), ctx, from)
}

// MockTagsConverter is a mock of TagsConverter interface.
type MockTagsConverter[A dto.Article, TA dto.TagArticle[A], O dto.TagsOutDto[A, TA]] struct {
	ctrl     *gomock.Controller
	recorder *MockTagsConverterMockRecorder[A, TA, O]
}

// MockTagsConverterMockRecorder is the mock recorder for MockTagsConverter.
type MockTagsConverterMockRecorder[A dto.Article, TA dto.TagArticle[A], O dto.TagsOutDto[A, TA]] struct {
	mock *MockTagsConverter[A, TA, O]
}

// NewMockTagsConverter creates a new mock instance.
func NewMockTagsConverter[A dto.Article, TA dto.TagArticle[A], O dto.TagsOutDto[A, TA]](ctrl *gomock.Controller) *MockTagsConverter[A, TA, O] {
	mock := &MockTagsConverter[A, TA, O]{ctrl: ctrl}
	mock.recorder = &MockTagsConverterMockRecorder[A, TA, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTagsConverter[A, TA, O]) EXPECT() *MockTagsConverterMockRecorder[A, TA, O] {
	return m.recorder
}

// ToTags mocks base method.
func (m *MockTagsConverter[A, TA, O]) ToTags(ctx context.Context, from O) (*model.TagConnection, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToTags", ctx, from)
	ret0, _ := ret[0].(*model.TagConnection)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ToTags indicates an expected call of ToTags.
func (mr *MockTagsConverterMockRecorder[A, TA, O]) ToTags(ctx, from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToTags", reflect.TypeOf((*MockTagsConverter[A, TA, O])(nil).ToTags), ctx, from)
}
