// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc

import (
	"context"

	"blogapi.miyamo.today/tag-service/internal/infra/rdb/types"
)

const getByID = `-- name: GetByID :one
SELECT
    t.id, t.name, t.created_at, t.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', a.id, 'title', a.title, 'thumbnail', a.thumbnail, 'created_at', a.created_at, 'updated_at', a.updated_at)
            ) FILTER (WHERE a.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "articles"
FROM
    (SELECT id, name, created_at, updated_at FROM "tags" WHERE "tags"."id" = $1) AS "t"
LEFT OUTER JOIN
    "articles" AS "a"
ON
    "t"."id" = "a"."tag_id"
GROUP BY "t"."id"
`

type GetByIDRow struct {
	ID        string         `db:"id"`
	Name      string         `db:"name"`
	CreatedAt types.UTCTime  `db:"created_at"`
	UpdatedAt types.UTCTime  `db:"updated_at"`
	Articles  types.Articles `db:"articles"`
}

func (q *Queries) GetByID(ctx context.Context, id string) (GetByIDRow, error) {
	row := q.queryRow(ctx, q.getByIDStmt, getByID, id)
	var i GetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Articles,
	)
	return i, err
}

const listAfter = `-- name: ListAfter :many
SELECT
    t.id, t.name, t.created_at, t.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', a.id, 'title', a.title, 'thumbnail', a.thumbnail, 'created_at', a.created_at, 'updated_at', a.updated_at)
            ) FILTER (WHERE a.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "articles"
FROM
    (SELECT id, name, created_at, updated_at FROM "tags" ORDER BY "tags"."id") AS "t"
LEFT OUTER JOIN
    "articles" AS "a"
ON
    "t"."id" = "a"."tag_id"
GROUP BY
    "t"."id"
ORDER BY
    "t"."id"
`

type ListAfterRow struct {
	ID        string         `db:"id"`
	Name      string         `db:"name"`
	CreatedAt types.UTCTime  `db:"created_at"`
	UpdatedAt types.UTCTime  `db:"updated_at"`
	Articles  types.Articles `db:"articles"`
}

func (q *Queries) ListAfter(ctx context.Context) ([]ListAfterRow, error) {
	rows, err := q.query(ctx, q.listAfterStmt, listAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAfterRow
	for rows.Next() {
		var i ListAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Articles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAfterWithLimit = `-- name: ListAfterWithLimit :many
SELECT
    t.id, t.name, t.created_at, t.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', a.id, 'title', a.title, 'thumbnail', a.thumbnail, 'created_at', a.created_at, 'updated_at', a.updated_at)
            ) FILTER (WHERE a.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "articles"
FROM
    (SELECT id, name, created_at, updated_at FROM "tags" ORDER BY "tags"."id" LIMIT $1) AS "t"
LEFT OUTER JOIN
    "articles" AS "a"
ON
    "t"."id" = "a"."tag_id"
GROUP BY
    "t"."id"
ORDER BY
    "t"."id"
`

type ListAfterWithLimitRow struct {
	ID        string         `db:"id"`
	Name      string         `db:"name"`
	CreatedAt types.UTCTime  `db:"created_at"`
	UpdatedAt types.UTCTime  `db:"updated_at"`
	Articles  types.Articles `db:"articles"`
}

func (q *Queries) ListAfterWithLimit(ctx context.Context, limit int32) ([]ListAfterWithLimitRow, error) {
	rows, err := q.query(ctx, q.listAfterWithLimitStmt, listAfterWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAfterWithLimitRow
	for rows.Next() {
		var i ListAfterWithLimitRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Articles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAfterWithLimitAndCursor = `-- name: ListAfterWithLimitAndCursor :many
SELECT
    t.id, t.name, t.created_at, t.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', a.id, 'title', a.title, 'thumbnail', a.thumbnail, 'created_at', a.created_at, 'updated_at', a.updated_at)
            ) FILTER (WHERE a.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "articles"
FROM
    (
        SELECT
            id, name, created_at, updated_at
        FROM
            "tags"
        WHERE
            EXISTS(
                SELECT id FROM "tags" WHERE "tags"."id" = $1
            )
        AND
            "tags"."id" > $1
        ORDER BY
            "tags"."id"
        LIMIT $2
    ) AS "t"
LEFT OUTER JOIN
    "articles" AS "a"
ON
    "t"."id" = "a"."tag_id"
GROUP BY
    "t"."id"
ORDER BY
    "t"."id"
`

type ListAfterWithLimitAndCursorParams struct {
	ID    string `db:"id"`
	Limit int32  `db:"limit"`
}

type ListAfterWithLimitAndCursorRow struct {
	ID        string         `db:"id"`
	Name      string         `db:"name"`
	CreatedAt types.UTCTime  `db:"created_at"`
	UpdatedAt types.UTCTime  `db:"updated_at"`
	Articles  types.Articles `db:"articles"`
}

func (q *Queries) ListAfterWithLimitAndCursor(ctx context.Context, arg ListAfterWithLimitAndCursorParams) ([]ListAfterWithLimitAndCursorRow, error) {
	rows, err := q.query(ctx, q.listAfterWithLimitAndCursorStmt, listAfterWithLimitAndCursor, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAfterWithLimitAndCursorRow
	for rows.Next() {
		var i ListAfterWithLimitAndCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Articles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBefore = `-- name: ListBefore :many
SELECT
    t.id, t.name, t.created_at, t.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', a.id, 'title', a.title, 'thumbnail', a.thumbnail, 'created_at', a.created_at, 'updated_at', a.updated_at)
            ) FILTER (WHERE a.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "articles"
FROM
    (SELECT id, name, created_at, updated_at FROM "tags" ORDER BY "tags"."id" DESC) AS "t"
LEFT OUTER JOIN
    "articles" AS "a"
ON
    "t"."id" = "a"."tag_id"
GROUP BY
    "t"."id"
ORDER BY
    "t"."id" DESC
`

type ListBeforeRow struct {
	ID        string         `db:"id"`
	Name      string         `db:"name"`
	CreatedAt types.UTCTime  `db:"created_at"`
	UpdatedAt types.UTCTime  `db:"updated_at"`
	Articles  types.Articles `db:"articles"`
}

func (q *Queries) ListBefore(ctx context.Context) ([]ListBeforeRow, error) {
	rows, err := q.query(ctx, q.listBeforeStmt, listBefore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBeforeRow
	for rows.Next() {
		var i ListBeforeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Articles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeforeWithLimit = `-- name: ListBeforeWithLimit :many
SELECT
    t.id, t.name, t.created_at, t.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', a.id, 'title', a.title, 'thumbnail', a.thumbnail, 'created_at', a.created_at, 'updated_at', a.updated_at)
            ) FILTER (WHERE a.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "articles"
FROM
    (SELECT id, name, created_at, updated_at FROM "tags" ORDER BY "tags"."id" DESC LIMIT $1) AS "t"
LEFT OUTER JOIN
    "articles" AS "a"
ON
    "t"."id" = "a"."tag_id"
GROUP BY
    "t"."id"
ORDER BY
    "t"."id" DESC
`

type ListBeforeWithLimitRow struct {
	ID        string         `db:"id"`
	Name      string         `db:"name"`
	CreatedAt types.UTCTime  `db:"created_at"`
	UpdatedAt types.UTCTime  `db:"updated_at"`
	Articles  types.Articles `db:"articles"`
}

func (q *Queries) ListBeforeWithLimit(ctx context.Context, limit int32) ([]ListBeforeWithLimitRow, error) {
	rows, err := q.query(ctx, q.listBeforeWithLimitStmt, listBeforeWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBeforeWithLimitRow
	for rows.Next() {
		var i ListBeforeWithLimitRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Articles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeforeWithLimitAndCursor = `-- name: ListBeforeWithLimitAndCursor :many
SELECT
    t.id, t.name, t.created_at, t.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', a.id, 'title', a.title, 'thumbnail', a.thumbnail, 'created_at', a.created_at, 'updated_at', a.updated_at)
            ) FILTER (WHERE a.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "articles"
FROM
    (
        SELECT
            id, name, created_at, updated_at
        FROM
            "tags"
        WHERE
            EXISTS(
                SELECT id FROM "tags" WHERE "tags"."id" = $1
            )
        AND
            "tags"."id" < $1
        ORDER BY
            "tags"."id" DESC
        LIMIT $2
    ) AS "t"
LEFT OUTER JOIN
    "articles" AS "a"
ON
    "t"."id" = "a"."tag_id"
GROUP BY
    "t"."id"
ORDER BY
    "t"."id" DESC
`

type ListBeforeWithLimitAndCursorParams struct {
	ID    string `db:"id"`
	Limit int32  `db:"limit"`
}

type ListBeforeWithLimitAndCursorRow struct {
	ID        string         `db:"id"`
	Name      string         `db:"name"`
	CreatedAt types.UTCTime  `db:"created_at"`
	UpdatedAt types.UTCTime  `db:"updated_at"`
	Articles  types.Articles `db:"articles"`
}

func (q *Queries) ListBeforeWithLimitAndCursor(ctx context.Context, arg ListBeforeWithLimitAndCursorParams) ([]ListBeforeWithLimitAndCursorRow, error) {
	rows, err := q.query(ctx, q.listBeforeWithLimitAndCursorStmt, listBeforeWithLimitAndCursor, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBeforeWithLimitAndCursorRow
	for rows.Next() {
		var i ListBeforeWithLimitAndCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Articles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
