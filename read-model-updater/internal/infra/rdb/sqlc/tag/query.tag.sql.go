// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.tag.sql

package tag

import (
	"context"

	"blogapi.miyamo.today/read-model-updater/internal/infra/rdb/types"
)

const createTempArticlesTable = `-- name: CreateTempArticlesTable :exec
CREATE TEMP TABLE IF NOT EXISTS tmp_articles (
    id VARCHAR(26),
    tag_id VARCHAR(144),
    title VARCHAR(255) NOT NULL,
    thumbnail VARCHAR(524271),
    created_at timestamp WITH TIME ZONE NOT NULL,
    updated_at timestamp WITH TIME ZONE NOT NULL
) ON COMMIT PRESERVE ROWS
`

func (q *Queries) CreateTempArticlesTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempArticlesTable)
	return err
}

const createTempTagsTable = `-- name: CreateTempTagsTable :exec
CREATE TEMP TABLE IF NOT EXISTS tmp_tags (
    id VARCHAR(144),
    name VARCHAR(35) NOT NULL,
    created_at timestamp WITH TIME ZONE NOT NULL,
    updated_at timestamp WITH TIME ZONE NOT NULL
) ON COMMIT PRESERVE ROWS
`

func (q *Queries) CreateTempTagsTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTagsTable)
	return err
}

type PrePutArticleParams struct {
	ID        string        `db:"id"`
	TagID     string        `db:"tag_id"`
	Title     string        `db:"title"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
}

type PrePutTagsParams struct {
	ID        string        `db:"id"`
	Name      string        `db:"name"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
}

const putArticle = `-- name: PutArticle :exec
WITH "inserted" AS (
    INSERT INTO "articles" (
        "id"
        ,"tag_id"
        ,"title"
        ,"thumbnail"
        ,"created_at"
        ,"updated_at"
    )
    SELECT
        DISTINCT ON(id, tag_id) id, tag_id, title, thumbnail, created_at, updated_at
    FROM (
        SELECT
            id, tag_id, title, thumbnail, created_at, updated_at
        FROM
            "tmp_articles"
        WHERE
            "tmp_articles"."id" = $1
        ORDER BY
            updated_at DESC
    )
    ON CONFLICT ("id","tag_id") DO UPDATE
        SET "title" = EXCLUDED.title
        ,"thumbnail" = EXCLUDED.thumbnail
        ,"updated_at" = EXCLUDED.updated_at
    RETURNING "tag_id"
)
DELETE
FROM
    "articles"
WHERE
    "articles"."id" = $1
AND
    "articles"."tag_id" NOT IN (SELECT tag_id FROM "inserted")
`

func (q *Queries) PutArticle(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, putArticle, id)
	return err
}

const putTags = `-- name: PutTags :exec
INSERT INTO "tags" (
    "id"
    ,"name"
    ,"created_at"
    ,"updated_at"
)
SELECT
    DISTINCT ON(id) id, name, created_at, updated_at
FROM (
    SELECT
        id, name, created_at, updated_at
    WHERE
        "tmp_tags"."id" = ANY ($1:: varchar [])
    ORDER BY updated_at DESC
)
ON CONFLICT DO NOTHING
`

func (q *Queries) PutTags(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, putTags, dollar_1)
	return err
}
