// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.tag.sql

package tag

import (
	"context"

	"blogapi.miyamo.today/read-model-updater/internal/infra/rdb/types"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTempArticlesTable = `-- name: CreateTempArticlesTable :exec
CREATE TEMP TABLE tmp_articles (
    id VARCHAR(26),
    tag_id VARCHAR(144),
    title VARCHAR(255) NOT NULL,
    thumbnail VARCHAR(524271),
    created_at timestamp WITH TIME ZONE NOT NULL,
    updated_at timestamp WITH TIME ZONE NOT NULL,
    FOREIGN KEY (tag_id) REFERENCES tags(id),
    PRIMARY KEY (id, tag_id)
) ON COMMIT PRESERVE ROWS
`

func (q *Queries) CreateTempArticlesTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempArticlesTable)
	return err
}

type PreTagArticlesParams struct {
	ID        string        `db:"id"`
	TagID     string        `db:"tag_id"`
	Title     string        `db:"title"`
	Thumbnail pgtype.Text   `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
}

const putTag = `-- name: PutTag :exec
INSERT INTO "tags" (
    "id"
    ,"name"
    ,"created_at"
    ,"updated_at"
)
VALUES (
    $1
    ,$2
    ,$3
    ,$4
)
ON CONFLICT ("id") DO UPDATE
SET "name" = EXCLUDED.name
,"updated_at" = EXCLUDED.updated_at
`

type PutTagParams struct {
	ID        string        `db:"id"`
	Name      string        `db:"name"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
}

func (q *Queries) PutTag(ctx context.Context, arg PutTagParams) error {
	_, err := q.db.Exec(ctx, putTag,
		arg.ID,
		arg.Name,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const tagArticles = `-- name: TagArticles :exec
WITH "inserted" AS (
    INSERT INTO "articles" (
        "id"
        ,"tag_id"
        ,"title"
        ,"thumbnail"
        ,"created_at"
        ,"updated_at"
    ) SELECT id, tag_id, title, thumbnail, created_at, updated_at FROM "tmp_articles"
    ON CONFLICT DO NOTHING
    RETURNING "id"
)
DELETE FROM "articles" WHERE "articles"."tag_id" = $1 AND "articles"."id" NOT IN (SELECT "id" FROM "inserted")
`

func (q *Queries) TagArticles(ctx context.Context, tagID string) error {
	_, err := q.db.Exec(ctx, tagArticles, tagID)
	return err
}
