// Code generated by MockGen. DO NOT EDIT.
// Source: converter.go
//
// Generated by this command:
//
//	mockgen -source=converter.go -destination=../../../../mock/if-adapter/controller/pb/presenter/mock_converter.go -package=presenter
//
// Package presenter is a generated GoMock package.
package presenter

import (
	reflect "reflect"

	usecase "github.com/miyamo2/blogapi-tag-service/internal/if-adapter/controller/pb/usecase"
	pb "github.com/miyamo2/blogproto-gen/tag/server/pb"
	gomock "go.uber.org/mock/gomock"
)

// MockToGetByIdConverter is a mock of ToGetByIdConverter interface.
type MockToGetByIdConverter[A usecase.Article, T usecase.Tag[A]] struct {
	ctrl     *gomock.Controller
	recorder *MockToGetByIdConverterMockRecorder[A, T]
}

// MockToGetByIdConverterMockRecorder is the mock recorder for MockToGetByIdConverter.
type MockToGetByIdConverterMockRecorder[A usecase.Article, T usecase.Tag[A]] struct {
	mock *MockToGetByIdConverter[A, T]
}

// NewMockToGetByIdConverter creates a new mock instance.
func NewMockToGetByIdConverter[A usecase.Article, T usecase.Tag[A]](ctrl *gomock.Controller) *MockToGetByIdConverter[A, T] {
	mock := &MockToGetByIdConverter[A, T]{ctrl: ctrl}
	mock.recorder = &MockToGetByIdConverterMockRecorder[A, T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToGetByIdConverter[A, T]) EXPECT() *MockToGetByIdConverterMockRecorder[A, T] {
	return m.recorder
}

// ToGetByIdTagResponse mocks base method.
func (m *MockToGetByIdConverter[A, T]) ToGetByIdTagResponse(from T) (*pb.GetTagByIdResponse, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToGetByIdTagResponse", from)
	ret0, _ := ret[0].(*pb.GetTagByIdResponse)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ToGetByIdTagResponse indicates an expected call of ToGetByIdTagResponse.
func (mr *MockToGetByIdConverterMockRecorder[A, T]) ToGetByIdTagResponse(from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToGetByIdTagResponse", reflect.TypeOf((*MockToGetByIdConverter[A, T])(nil).ToGetByIdTagResponse), from)
}

// MockToGetAllConverter is a mock of ToGetAllConverter interface.
type MockToGetAllConverter[A usecase.Article, T usecase.Tag[A], O usecase.GetAllOutDto[A, T]] struct {
	ctrl     *gomock.Controller
	recorder *MockToGetAllConverterMockRecorder[A, T, O]
}

// MockToGetAllConverterMockRecorder is the mock recorder for MockToGetAllConverter.
type MockToGetAllConverterMockRecorder[A usecase.Article, T usecase.Tag[A], O usecase.GetAllOutDto[A, T]] struct {
	mock *MockToGetAllConverter[A, T, O]
}

// NewMockToGetAllConverter creates a new mock instance.
func NewMockToGetAllConverter[A usecase.Article, T usecase.Tag[A], O usecase.GetAllOutDto[A, T]](ctrl *gomock.Controller) *MockToGetAllConverter[A, T, O] {
	mock := &MockToGetAllConverter[A, T, O]{ctrl: ctrl}
	mock.recorder = &MockToGetAllConverterMockRecorder[A, T, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToGetAllConverter[A, T, O]) EXPECT() *MockToGetAllConverterMockRecorder[A, T, O] {
	return m.recorder
}

// ToGetAllTagsResponse mocks base method.
func (m *MockToGetAllConverter[A, T, O]) ToGetAllTagsResponse(from O) (*pb.GetAllTagsResponse, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToGetAllTagsResponse", from)
	ret0, _ := ret[0].(*pb.GetAllTagsResponse)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ToGetAllTagsResponse indicates an expected call of ToGetAllTagsResponse.
func (mr *MockToGetAllConverterMockRecorder[A, T, O]) ToGetAllTagsResponse(from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToGetAllTagsResponse", reflect.TypeOf((*MockToGetAllConverter[A, T, O])(nil).ToGetAllTagsResponse), from)
}

// MockToGetNextConverter is a mock of ToGetNextConverter interface.
type MockToGetNextConverter[A usecase.Article, T usecase.Tag[A], O usecase.GetNextOutDto[A, T]] struct {
	ctrl     *gomock.Controller
	recorder *MockToGetNextConverterMockRecorder[A, T, O]
}

// MockToGetNextConverterMockRecorder is the mock recorder for MockToGetNextConverter.
type MockToGetNextConverterMockRecorder[A usecase.Article, T usecase.Tag[A], O usecase.GetNextOutDto[A, T]] struct {
	mock *MockToGetNextConverter[A, T, O]
}

// NewMockToGetNextConverter creates a new mock instance.
func NewMockToGetNextConverter[A usecase.Article, T usecase.Tag[A], O usecase.GetNextOutDto[A, T]](ctrl *gomock.Controller) *MockToGetNextConverter[A, T, O] {
	mock := &MockToGetNextConverter[A, T, O]{ctrl: ctrl}
	mock.recorder = &MockToGetNextConverterMockRecorder[A, T, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToGetNextConverter[A, T, O]) EXPECT() *MockToGetNextConverterMockRecorder[A, T, O] {
	return m.recorder
}

// ToGetNextTagsResponse mocks base method.
func (m *MockToGetNextConverter[A, T, O]) ToGetNextTagsResponse(from O) (*pb.GetNextTagResponse, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToGetNextTagsResponse", from)
	ret0, _ := ret[0].(*pb.GetNextTagResponse)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ToGetNextTagsResponse indicates an expected call of ToGetNextTagsResponse.
func (mr *MockToGetNextConverterMockRecorder[A, T, O]) ToGetNextTagsResponse(from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToGetNextTagsResponse", reflect.TypeOf((*MockToGetNextConverter[A, T, O])(nil).ToGetNextTagsResponse), from)
}

// MockToGetPrevConverter is a mock of ToGetPrevConverter interface.
type MockToGetPrevConverter[A usecase.Article, T usecase.Tag[A], O usecase.GetPrevOutDto[A, T]] struct {
	ctrl     *gomock.Controller
	recorder *MockToGetPrevConverterMockRecorder[A, T, O]
}

// MockToGetPrevConverterMockRecorder is the mock recorder for MockToGetPrevConverter.
type MockToGetPrevConverterMockRecorder[A usecase.Article, T usecase.Tag[A], O usecase.GetPrevOutDto[A, T]] struct {
	mock *MockToGetPrevConverter[A, T, O]
}

// NewMockToGetPrevConverter creates a new mock instance.
func NewMockToGetPrevConverter[A usecase.Article, T usecase.Tag[A], O usecase.GetPrevOutDto[A, T]](ctrl *gomock.Controller) *MockToGetPrevConverter[A, T, O] {
	mock := &MockToGetPrevConverter[A, T, O]{ctrl: ctrl}
	mock.recorder = &MockToGetPrevConverterMockRecorder[A, T, O]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToGetPrevConverter[A, T, O]) EXPECT() *MockToGetPrevConverterMockRecorder[A, T, O] {
	return m.recorder
}

// ToGetPrevTagsResponse mocks base method.
func (m *MockToGetPrevConverter[A, T, O]) ToGetPrevTagsResponse(from O) (*pb.GetPrevTagResponse, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToGetPrevTagsResponse", from)
	ret0, _ := ret[0].(*pb.GetPrevTagResponse)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// ToGetPrevTagsResponse indicates an expected call of ToGetPrevTagsResponse.
func (mr *MockToGetPrevConverterMockRecorder[A, T, O]) ToGetPrevTagsResponse(from any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToGetPrevTagsResponse", reflect.TypeOf((*MockToGetPrevConverter[A, T, O])(nil).ToGetPrevTagsResponse), from)
}
