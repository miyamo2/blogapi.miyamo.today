// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc

import (
	"context"

	"blogapi.miyamo.today/article-service/internal/infra/rdb/types"
)

const getByID = `-- name: GetByID :one
SELECT 
    a.id, a.title, a.body, a.thumbnail, a.created_at, a.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', t.id, 'name', t.name)
            ) FILTER (WHERE t.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "tags" 
FROM 
    (SELECT id, title, body, thumbnail, created_at, updated_at FROM "articles" WHERE "articles"."id" = $1) AS "a" 
LEFT OUTER JOIN 
    "tags" AS "t"  
ON 
    "a"."id" = "t"."article_id" 
GROUP BY 
    "a"."id"
`

type GetByIDRow struct {
	ID        string        `db:"id"`
	Title     string        `db:"title"`
	Body      string        `db:"body"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
	Tags      types.Tags    `db:"tags"`
}

func (q *Queries) GetByID(ctx context.Context, id string) (GetByIDRow, error) {
	row := q.queryRow(ctx, q.getByIDStmt, getByID, id)
	var i GetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Body,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Tags,
	)
	return i, err
}

const listAfter = `-- name: ListAfter :many
SELECT
    a.id, a.title, a.body, a.thumbnail, a.created_at, a.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', t.id, 'name', t.name)
            ) FILTER (WHERE t.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "tags" 
FROM
    (SELECT id, title, body, thumbnail, created_at, updated_at FROM "articles" ORDER BY "articles"."id") AS "a" 
LEFT OUTER JOIN
    "tags" AS "t" 
ON
    "t"."id" = "a"."tag_id"
GROUP BY 
    "a"."id"
ORDER BY
    "a"."id"
`

type ListAfterRow struct {
	ID        string        `db:"id"`
	Title     string        `db:"title"`
	Body      string        `db:"body"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
	Tags      types.Tags    `db:"tags"`
}

func (q *Queries) ListAfter(ctx context.Context) ([]ListAfterRow, error) {
	rows, err := q.query(ctx, q.listAfterStmt, listAfter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAfterRow
	for rows.Next() {
		var i ListAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAfterWithLimit = `-- name: ListAfterWithLimit :many
SELECT
    a.id, a.title, a.body, a.thumbnail, a.created_at, a.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', t.id, 'name', t.name)
            ) FILTER (WHERE t.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "tags" 
FROM
    (SELECT id, title, body, thumbnail, created_at, updated_at FROM "articles" ORDER BY "articles"."id" LIMIT $1) AS "a" 
LEFT OUTER JOIN
    "tags" AS "t"
ON
    "t"."id" = "a"."tag_id"
GROUP BY 
    "a"."id"
ORDER BY
    "a"."id"
`

type ListAfterWithLimitRow struct {
	ID        string        `db:"id"`
	Title     string        `db:"title"`
	Body      string        `db:"body"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
	Tags      types.Tags    `db:"tags"`
}

func (q *Queries) ListAfterWithLimit(ctx context.Context, limit int32) ([]ListAfterWithLimitRow, error) {
	rows, err := q.query(ctx, q.listAfterWithLimitStmt, listAfterWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAfterWithLimitRow
	for rows.Next() {
		var i ListAfterWithLimitRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAfterWithLimitAndCursor = `-- name: ListAfterWithLimitAndCursor :many
SELECT
    a.id, a.title, a.body, a.thumbnail, a.created_at, a.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', t.id, 'name', t.name)
            ) FILTER (WHERE t.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "tags" 
FROM
    (
        SELECT
            id, title, body, thumbnail, created_at, updated_at
        FROM
            "articles"
        WHERE
            EXISTS(
                SELECT id FROM "articles" WHERE "articles"."id" = $1
            )
        AND
            "articles"."id" > $1
        ORDER BY
            "articles"."id"
        LIMIT $2
    ) AS "a" 
LEFT OUTER JOIN
    "tags" AS "t" 
ON
    "t"."id" = "a"."tag_id"
GROUP BY 
    "a"."id"
ORDER BY
    "a"."id"
`

type ListAfterWithLimitAndCursorParams struct {
	ID    string `db:"id"`
	Limit int32  `db:"limit"`
}

type ListAfterWithLimitAndCursorRow struct {
	ID        string        `db:"id"`
	Title     string        `db:"title"`
	Body      string        `db:"body"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
	Tags      types.Tags    `db:"tags"`
}

func (q *Queries) ListAfterWithLimitAndCursor(ctx context.Context, arg ListAfterWithLimitAndCursorParams) ([]ListAfterWithLimitAndCursorRow, error) {
	rows, err := q.query(ctx, q.listAfterWithLimitAndCursorStmt, listAfterWithLimitAndCursor, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAfterWithLimitAndCursorRow
	for rows.Next() {
		var i ListAfterWithLimitAndCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBefore = `-- name: ListBefore :many
SELECT
    a.id, a.title, a.body, a.thumbnail, a.created_at, a.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', t.id, 'name', t.name)
            ) FILTER (WHERE t.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "tags" 
FROM
    (SELECT id, title, body, thumbnail, created_at, updated_at FROM "articles" ORDER BY "articles"."id" DESC) AS "a"
LEFT OUTER JOIN
    "tags" AS "t" 
ON
    "t"."id" = "a"."tag_id"
GROUP BY 
    "a"."id"
ORDER BY
    "a"."id" DESC
`

type ListBeforeRow struct {
	ID        string        `db:"id"`
	Title     string        `db:"title"`
	Body      string        `db:"body"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
	Tags      types.Tags    `db:"tags"`
}

func (q *Queries) ListBefore(ctx context.Context) ([]ListBeforeRow, error) {
	rows, err := q.query(ctx, q.listBeforeStmt, listBefore)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBeforeRow
	for rows.Next() {
		var i ListBeforeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeforeWithLimit = `-- name: ListBeforeWithLimit :many
SELECT
    a.id, a.title, a.body, a.thumbnail, a.created_at, a.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', t.id, 'name', t.name)
            ) FILTER (WHERE t.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "tags" 
FROM
    (SELECT id, title, body, thumbnail, created_at, updated_at FROM "articles" ORDER BY "articles"."id" DESC LIMIT $1) AS "a"
LEFT OUTER JOIN
    "tags" AS "t" 
ON
    "t"."id" = "a"."tag_id"
GROUP BY 
    "a"."id"
ORDER BY
    "a"."id" DESC
`

type ListBeforeWithLimitRow struct {
	ID        string        `db:"id"`
	Title     string        `db:"title"`
	Body      string        `db:"body"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
	Tags      types.Tags    `db:"tags"`
}

func (q *Queries) ListBeforeWithLimit(ctx context.Context, limit int32) ([]ListBeforeWithLimitRow, error) {
	rows, err := q.query(ctx, q.listBeforeWithLimitStmt, listBeforeWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBeforeWithLimitRow
	for rows.Next() {
		var i ListBeforeWithLimitRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeforeWithLimitAndCursor = `-- name: ListBeforeWithLimitAndCursor :many
SELECT
    a.id, a.title, a.body, a.thumbnail, a.created_at, a.updated_at,
    CAST(
        COALESCE(
            jsonb_agg(
                json_build_object('id', t.id, 'name', t.name)
            ) FILTER (WHERE t.id IS NOT NULL), '[]'::json
        ) AS json
    ) AS "tags" 
FROM
    (
        SELECT
            id, title, body, thumbnail, created_at, updated_at
        FROM
            "articles"
        WHERE
            EXISTS(
                SELECT id FROM "articles" WHERE "articles"."id" = $1
            )
        AND
            "articles"."id" < $1
        ORDER BY
            "articles"."id" DESC
        LIMIT $2
    ) AS "a" 
LEFT OUTER JOIN
    "tags" AS "t" 
ON
    "t"."id" = "a"."tag_id"
GROUP BY 
    "a"."id"
ORDER BY
    "a"."id" DESC
`

type ListBeforeWithLimitAndCursorParams struct {
	ID    string `db:"id"`
	Limit int32  `db:"limit"`
}

type ListBeforeWithLimitAndCursorRow struct {
	ID        string        `db:"id"`
	Title     string        `db:"title"`
	Body      string        `db:"body"`
	Thumbnail string        `db:"thumbnail"`
	CreatedAt types.UTCTime `db:"created_at"`
	UpdatedAt types.UTCTime `db:"updated_at"`
	Tags      types.Tags    `db:"tags"`
}

func (q *Queries) ListBeforeWithLimitAndCursor(ctx context.Context, arg ListBeforeWithLimitAndCursorParams) ([]ListBeforeWithLimitAndCursorRow, error) {
	rows, err := q.query(ctx, q.listBeforeWithLimitAndCursorStmt, listBeforeWithLimitAndCursor, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBeforeWithLimitAndCursorRow
	for rows.Next() {
		var i ListBeforeWithLimitAndCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Body,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
